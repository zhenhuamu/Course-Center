<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Spectral:300,300italic,400,400italic,700,700italic|Frijole:300,300italic,400,400italic,700,700italic|Copse:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="我是一只有点懒惰的小蚂蚁,为着自己的大米在码农的日子上渐行渐远。">
<meta property="og:type" content="website">
<meta property="og:title" content="AndyMu">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="AndyMu">
<meta property="og:description" content="我是一只有点懒惰的小蚂蚁,为着自己的大米在码农的日子上渐行渐远。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AndyMu">
<meta name="twitter:description" content="我是一只有点懒惰的小蚂蚁,为着自己的大米在码农的日子上渐行渐远。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>AndyMu</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2f238e42b6a0fb6febddb7c69e4d1198";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AndyMu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/22/Effective-Objecive-C-2-0-读书笔记（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AndyMu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyMu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/06/22/Effective-Objecive-C-2-0-读书笔记（三）/" itemprop="url">Effective-Objecive-C-2-0-读书笔记（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-22T17:49:08+08:00">
                2014-06-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2014/06/22/Effective-Objecive-C-2-0-读书笔记（三）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/06/22/Effective-Objecive-C-2-0-读书笔记（三）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="21-理解Objective-C错误模型"><a href="#21-理解Objective-C错误模型" class="headerlink" title="21.理解Objective-C错误模型"></a>21.理解Objective-C错误模型</h2><hr>
<ul>
<li><code>Objective-C</code> 语言现在采用的办法是：只在及其罕见的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。</li>
<li>在出现”不那么严重的错误”时，<code>Objective-C</code> 语言所用的编程范式为：令方法返回nil/0，或者使用<code>NSError</code> 。</li>
<li><code>NSError</code> 对象封装了三条信息<br><code>Error domain</code>  (错误范围，其类型为字符串)  错误发生的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义<br><code>Error code</code>  (错误码，其类型为整数) 独有的错误代码，用以指明在某个范围内具体发生了何种错误<br><code>User info</code> (用户信息，其类型为字典) 有关此错误的额外信息，其中或许包含一段”本地化的描述”</li>
</ul>
<blockquote>
<p>只有发生了可是整个应用程序崩溃的严重错误时，才应该使用异常</p>
<p>在错误不那么严重的情况下，可以指派”委托方法”来处理错误，也可以把错误信息放在<code>NSError</code>中，经由”输出参数”返回给调用者</p>
</blockquote>
<h2 id="22-理解NSCopying协议"><a href="#22-理解NSCopying协议" class="headerlink" title="22.理解NSCopying协议"></a>22.理解NSCopying协议</h2><hr>
<ul>
<li><code>NSCopying</code>协议只有一个方法<code>- (id)copyWithZone:(nullable NSZone *)zone</code></li>
<li><code>copy</code>方法由<code>NSObject</code>实现，该方法只是以”默认区”为参数来调用<code>“copyWihZone”</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (instancetype)copyWithZone:(NSZone*)zone &#123;</div><div class="line">    return [[[self class] allocWithZone:zone] initWithSessionConfiguration:self.session.configuration</div><div class="line">];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>实现此功能的完整代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface LNLocation : NSObject</div><div class="line">- (instancetype)initWithLongitude:(NSString *)longitude andLatitude:(NSString *)latitude;</div><div class="line">@property(nonatomic, copy)NSString *longitude;</div><div class="line">@property(nonatomic, copy)NSString *latitude;</div><div class="line">@end</div><div class="line"></div><div class="line">#import &quot;LNLocation.h&quot;</div><div class="line">@interface LNLocation()&lt;NSCopying&gt;&#123;</div><div class="line">    NSString *_locationInfo;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">@implementation LNLocation</div><div class="line"></div><div class="line">- (instancetype)initWithLongitude:(NSString *)longitude andLatitude:(NSString *)latitude&#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        _longitude = [longitude copy];</div><div class="line">        _latitude = [latitude copy];</div><div class="line">        _locationInfo = [NSString new];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)copyWithZone:(NSZone *)zone&#123;</div><div class="line">    LNLocation *location = [[[self class] allocWithZone:zone] initWithLongitude:_latitude andLatitude:_latitude];</div><div class="line">    location -&gt; _locationInfo = [_locationInfo copy];</div><div class="line">    return location;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>对于不可变的<code>NSArray</code>与可变的<code>NSMutableArray</code>来说，下列关系总是成立的<br><code>[NSMutableArray copy] ==&gt; NSArray</code><br><code>[NSArray mutablecopy] ==&gt; NSMutableArray</code></li>
<li>深拷贝的意思局势:在拷贝对象自身时，将其底层数据也一并复制过去。<code>Foundation</code>框架中的所有<code>collection</code>类在默认情况下都执行浅拷贝，也就是说，只拷贝容器对象本身，而不复制其中数据。<br><img src="/2014/06/22/Effective-Objecive-C-2-0-读书笔记（三）/1.png" alt="1"></li>
</ul>
<blockquote>
<p>若想令自己所写的对象具有拷贝功能，则需实现<code>NSCopying</code>协议</p>
<p>如果自定义的对象分为可变版本与不可变版本，那么就要同时实现<code>NSCopying</code>与<code>NSMutableCopying</code>协议</p>
<p>复制对象时需决定采用浅拷贝还是深拷贝，一帮情况下应该尽量执行浅拷贝</p>
<p>如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法</p>
</blockquote>
<h2 id="23-通过委托与数据源协议进行对象间通信"><a href="#23-通过委托与数据源协议进行对象间通信" class="headerlink" title="23.通过委托与数据源协议进行对象间通信"></a>23.通过委托与数据源协议进行对象间通信</h2><hr>
<ul>
<li>委托模式的主旨是:定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其”委托对象”。而这”另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象<br><img src="/2014/06/22/Effective-Objecive-C-2-0-读书笔记（三）/2.png" alt="2"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@protocol TDRectangleDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">-(void)networkFetcher:(TDRectangle *)rectangle didReceiveData:(NSData*)data;</div><div class="line">-(void)networkFetcher:(TDRectangle *)rectangle didFailWithError:(NSError*)error;</div><div class="line"></div><div class="line">@end</div><div class="line">@interface TDRectangle : NSObject</div><div class="line">@property(nonatomic,weak)id&lt;TDRectangleDelegate&gt;delegate;</div></pre></td></tr></table></figure>
<ul>
<li>注意：这个属性需定义成<code>weak</code>，而非<code>strong</code>，因为两者之间必须为”非拥有关系”。</li>
<li>若要遵从委托协议，可以在其接口中声明，也可以在”<code>class-continuation</code>分类”中声明，一般情况下都在”<code>class-continuation</code>分类”中声明</li>
<li>委托协议中的方法一般都是”可选(<code>optional</code>)的”，因为受委托者角色的这个对象未必关系其中的所有方法</li>
<li>如果要在委托对象上调用可选方法，那么必须提前使用类型信息查询方法判断这个委托对象能否响应先关选择子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)callBack&#123;   </div><div class="line">if ([_delegate respondsToSelector:@selector</div><div class="line">(networkFetcher:didReceiveData:)]) &#123;</div><div class="line">        [_delegate networkFetcher:self didReceiveData:nil];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象</p>
<p>将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法</p>
<p>当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情景下，该模式亦称”数据源协议”</p>
<p>若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中</p>
</blockquote>
<h2 id="24-将类的实现代码分散到便于管理的数个分类之中"><a href="#24-将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="24.将类的实现代码分散到便于管理的数个分类之中"></a>24.将类的实现代码分散到便于管理的数个分类之中</h2><hr>
<ul>
<li>类中经常容易填满各种方法，而这些方法的代码则全部推在一个巨大的实现文件里。有时这么做是合理的，因为即便通过重构把这个类打散，效果也不会更好。在此轻卡况下，可以通过<code>Objective-C</code>的”分类”机制，把类代码按逻辑划分几个分类中。</li>
</ul>
<blockquote>
<p>使用分类制把类的实现代码划分成易于管理的小块</p>
<p>将应该视为”私有”的方法归入名叫<code>private</code>的分类中，以隐藏实现细节</p>
</blockquote>
<h2 id="25-总是为第三方类的分类名称加前缀"><a href="#25-总是为第三方类的分类名称加前缀" class="headerlink" title="25.总是为第三方类的分类名称加前缀"></a>25.总是为第三方类的分类名称加前缀</h2><hr>
<ul>
<li>分类中的方法是直接添加在类里面的，他们就好比这个类中的固有方法。将分类方法加入类中这一操作是在运行期系统加载分类时完成的。运行期系统会把分类中所有实现的每个方法都加入类的方法列表中。如果类中本来就有此方法，而分类又实现了一次，那么分类中的方法会覆盖原来那一份实现代码。</li>
<li>要解决覆盖的问题，一般的做法是：以命名空间来区别各个分类的名称与其中所定义的方法。想在<code>Objective-C</code>中实现命名空间功能，只有一个办法，就是给相关名称都加上某个公用的前缀。</li>
</ul>
<blockquote>
<p>向第三方类中添加分类时，总应给其名称加上你专用的前缀</p>
<p>向第三方类中添加分类时，总应给其中的方法加上你专用的前缀</p>
</blockquote>
<h2 id="26-勿在分类中声明属性"><a href="#26-勿在分类中声明属性" class="headerlink" title="26.勿在分类中声明属性"></a>26.勿在分类中声明属性</h2><hr>
<ul>
<li>属性是封装数据的方式。尽管从技术上说，分类里也可以申明属性，但这种做法还是要尽量避免。原因在于，除了”<code>class-continuation</code>分类”之外，其他分类都无法向类中新增实例变量。</li>
<li>关联对象能够解决在分类中不能合成实例变量的问题，这样做可行，但不太理想，并不推荐。把属性定义在”主接口”中要比定义在分类里清晰的多</li>
<li>有时候只读属性还是可以再分类中使用的。由于获取方法并不访问数据，而且属性也不需要由实例变量来实现。于是，编译器也就不会发出警告信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)setMj_x:(CGFloat)mj_x&#123;</div><div class="line">CGRect frame = self.frame;</div><div class="line">frame.origin.x= mj_x;  </div><div class="line">self.frame = frame;</div><div class="line">&#125;</div><div class="line">- (CGFloat)mj_x&#123;   </div><div class="line">return self.frame.origin.x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>把封装数据所用的全部属性都定义在主接口里</p>
<p>在”<code>class-continuation</code>分类”之外的其他分类中，可以定义存取方法，但尽量不要定义属性</p>
</blockquote>
<h2 id="27-使用”class-continuation-分类”隐藏实现细节"><a href="#27-使用”class-continuation-分类”隐藏实现细节" class="headerlink" title="27.使用”class-continuation 分类”隐藏实现细节"></a>27.使用”class-continuation 分类”隐藏实现细节</h2><hr>
<ul>
<li>“<code>class-continuation</code>分类”和普通的分类不同，它必须定义在其所接续的那个类的实现文件里。其重要之处在于，这是唯一能声明实例变量的分类，而且此分类没有特定的实现文件，其中的方法都应该定义在类的主实现文件里。</li>
<li><code>Objective-C++</code>是<code>Objective-C</code>与<code>C++</code>的混合体，其代码可以用这两种语言来编写。.mm扩展名表示编译器应该将此文件按<code>Objective-C++</code>来编译，可以使用分类解决头文件中引入<code>C++</code>文件</li>
<li>“<code>class-continuation</code>分类”还有一种合理用法，就是将<code>public</code>接口中声明为”只读”的属性扩展为”可读写”，以便在类的内部设置其值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@interface TDRectangle : NSObject</div><div class="line">@property(nonatomic,assign,readonly)float width;</div><div class="line">@property(nonatomic,assign,readonly)float height;</div><div class="line">@end</div><div class="line">@interface TDRectangle()</div><div class="line">@property(nonatomic,assign,readwrite)float width;</div><div class="line">@property(nonatomic,assign,readwrite)float height;</div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>通过”<code>class-continuation</code>分类”向类中新增实例变量</p>
<p>如果某属性在主接口声明为”只读”，而类的内部又要设置方法修改此属性，那么就在”<code>class-continuation</code>分类”中将其扩展为”可读写”</p>
<p>把私有方法的原型声明在”<code>class-continuation</code> 分类”里面</p>
<p>若想使类所遵循的协议不为所知，则可与”<code>class-continuation</code> 分类”中声明</p>
</blockquote>
<h2 id="28-通过协议提供匿名对象"><a href="#28-通过协议提供匿名对象" class="headerlink" title="28.通过协议提供匿名对象"></a>28.通过协议提供匿名对象</h2><hr>
<blockquote>
<p>协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法</p>
<p>使用匿名对象来隐藏类型名称(或类名)</p>
<p>如果具体类型不重要，重要的是对象能够响应(定义在协议里)特定方法，那么可使用匿名对象来表示</p>
</blockquote>
<h2 id="29-理解引用计数"><a href="#29-理解引用计数" class="headerlink" title="29.理解引用计数"></a>29.理解引用计数</h2><hr>
<ul>
<li>在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活下去。这在<code>Objective-C</code>中叫做”保留计数”</li>
<li><code>NSObject</code>协议声明了下面三个方法用于操作计数器，以递增或递减其值:<br><code>retain</code> 递增保留计数<br><code>release</code> 递减保留计数<br><code>autorelease</code> 待稍后清理”自动释放池”(<code>autorelease pool</code>)时，再递减保留计数。<br><img src="/2014/06/22/Effective-Objecive-C-2-0-读书笔记（三）/3.png" alt="3"><br><img src="/2014/06/22/Effective-Objecive-C-2-0-读书笔记（三）/4.png" alt="4"></li>
<li>为避免在不经意间使用了无效对象，一般调用完<code>release</code>之后都会清空指针。这就能保证不会出现可能指向无效对象的指针，这种指针通常称为”悬挂指针”</li>
<li>属性存取方法中的内存管理  （此方法将保留新值并释放旧值，然后更新实例变量，令其指向新值）<br><img src="/2014/06/22/Effective-Objecive-C-2-0-读书笔记（三）/5.png" alt="5"></li>
</ul>
<blockquote>
<p>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。</p>
<p>在对象生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数</p>
</blockquote>
<h2 id="30-以ARC简化引用计数"><a href="#30-以ARC简化引用计数" class="headerlink" title="30.以ARC简化引用计数"></a>30.以ARC简化引用计数</h2><hr>
<ul>
<li>Clang编译器项目带有一个”静态分析器”，用于指明程序里引用计数出问题的地方</li>
<li>由于ARC会自动执行<code>retain</code>、<code>release</code>、<code>autorelease</code>等操作，所以直接在ARC下调用这些内存管理方法是非法的。<br><code>retain</code>、<code>release</code>、<code>autorelease</code>、<code>dealloc</code></li>
<li>若方法名以下列词语开头，则其返回的对象归调用者所有 <code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code></li>
<li>默认情况下，每个变量都是指向对象的强引用。</li>
<li><code>__strong</code>：默认语义，保留此值</li>
<li><code>__unsafe_unretained</code>：不保留此值，这么做可能不安全，因为等到再次使用变量时，其对象可能已经回收了</li>
<li><code>__weak</code>：不保留此值，但是变量可以安全使用,因为如果系统把这个对象回收了，那么变量也会自动清空</li>
<li><code>__autoreleaseing</code>：把对象”按引用传递”给方法时，使用这个特殊的修饰符。此值在方法返回时自动释放</li>
<li>如果有非<code>Objective-C</code>的对象，比如<code>CoreFoundation</code>中的对象或是由<code>malloc()</code>分配在堆中的内存，那么仍然需要清理。</li>
</ul>
<blockquote>
<p>有ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可省去类中的许多”样板代码”</p>
<p>ARC管理对象生命期的办法基本上就是：在合适的地方插入”保留”及”释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行”保留”及”释放”操作</p>
<p>由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC将此确定为开发者必须遵守的规则</p>
<p>ARC只负责管理<code>Objective-C</code>对象的内存。尤其要注意：<code>CoreFoudation</code>对象不归ARC管理，开发者必须适时调用<code>CFRetain/CFRelease</code></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/16/Effective-Objecive-C-2-0-读书笔记（二）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AndyMu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyMu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/06/16/Effective-Objecive-C-2-0-读书笔记（二）/" itemprop="url">Effective-Objecive-C-2-0-读书笔记（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-16T16:20:52+08:00">
                2014-06-16
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2014/06/16/Effective-Objecive-C-2-0-读书笔记（二）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/06/16/Effective-Objecive-C-2-0-读书笔记（二）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="11-理解objc-msgSend的作用"><a href="#11-理解objc-msgSend的作用" class="headerlink" title="11.理解objc_msgSend的作用"></a>11.理解objc_msgSend的作用</h2><hr>
<ul>
<li>由于<code>Objective-C</code>是C的超集，所以最好先理解C语言的函数调用方式。C语言使用”静态绑定”，也就是说，在编译期就能决定运行时所应调用的函数。</li>
<li>只有一个函数指令,不过待调用的函数地址无法硬编译在指令之中，而是要在运行期读取出来，这是”动态绑定”</li>
<li>C语言函数调用，所调用的函数乃是消息传递机制中的核心函数，叫做<code>objc_msgSend</code>  </li>
<li><code>((void (*)(id, SEL)objc_msgSend(self,@selector(selector))))</code> </li>
</ul>
<blockquote>
<p>消息由接收者、选择子及参数构成。给某对象”发送消息”也就相当于在该&gt; 对象上”调用方法”</p>
<p>发给某对象的全部消息都要由”动态消息派发系统”来处理，该系统会查出对应的方法，并执行其代码</p>
</blockquote>
<h2 id="12-理解消息转发机制"><a href="#12-理解消息转发机制" class="headerlink" title="12.理解消息转发机制"></a>12.理解消息转发机制</h2><hr>
<ul>
<li>在编译期向类发送了其无法解读的消息并不会报错，因为在运行期可以继续向类中添加方法，所以编译器在编译时还无法确知类中到底会不会有某个方法实现，当对象接收到无法解读的消息后，就会启动”消息转发”机制</li>
<li>消息转发两大阶段，第一阶段先征询接受者，所属的类，看其是否能动态添加方法，以处理当前这个”未知的选择子”，这叫做”动态方法解析”。第二阶段即第一级段执行完了，接受者看看有没有其他手段来处理与消息相关的方法调用，则运行期系统会把消息转给那个对象，转发过程结束。若没有”备援的接受者“，则启动完整的消息转发机制，运行期会把消息有关的全部细节都封装到<code>NSIvocation</code>对象中，再给接受者最后一次机会。</li>
<li>动态方法解析 — 对象在收到无法解读的消息后，首先调用其所属类的下列类方法 </li>
<li><code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>  常用于实现<code>@dynamic</code>属性</li>
<li>备援接受者<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>  注意我们无法操作经由这一步转发的消息。若是想在发送给备援接受者之前先修改消息内容，那就得通过完整的消息转发机制来做了</li>
<li>完整的消息转发<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code> </li>
</ul>
<p>完整的例子演示动态方法解析  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface LNAutoDictionary : NSObject</div><div class="line">@property(nonatomic, strong)NSString *string;</div><div class="line">@property(nonatomic, strong)NSNumber *number;</div><div class="line">@property(nonatomic, strong)NSDate *date;</div><div class="line">@property(nonatomic, strong)id opaqueObject;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">#import &quot;LNAutoDictionary.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@interface LNAutoDictionary()</div><div class="line">@property(nonatomic,strong)NSMutableDictionary *backingStore;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation LNAutoDictionary</div><div class="line">@dynamic string,number,date,opaqueObject;</div><div class="line"></div><div class="line">- (id)init&#123;</div><div class="line">    if ((self = [super init])) &#123;</div><div class="line">        _backingStore = [NSMutableDictionary new];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</div><div class="line">    NSString *selectorString = NSStringFromSelector(sel);</div><div class="line">    if ([selectorString hasPrefix:@&quot;set&quot;]) &#123;</div><div class="line">        class_addMethod(self, sel, (IMP)autoDictionarySetter, &quot;v@:@&quot;);</div><div class="line">    &#125;else&#123;</div><div class="line">        class_addMethod(self, sel, (IMP)autoDictionaryGetter, &quot;v@:@&quot;);</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">id autoDictionaryGetter(id self, SEL _cmd)&#123;</div><div class="line">    //Get the backing store from the object</div><div class="line">    LNAutoDictionary *typedSelf = (LNAutoDictionary *)self;</div><div class="line">    NSMutableDictionary *backingStore = typedSelf.backingStore;</div><div class="line">    //The key is simply the selector name</div><div class="line">    NSString *key = NSStringFromSelector(_cmd);</div><div class="line">    //Return the value</div><div class="line">    return [backingStore objectForKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void autoDictionarySetter(id self, SEL _cmd, id value)&#123;</div><div class="line">    //Get the backing store from the object</div><div class="line">    LNAutoDictionary *typedSelf = (LNAutoDictionary *)self;</div><div class="line">    NSMutableDictionary *backingStore = typedSelf.backingStore;</div><div class="line">    /**</div><div class="line">     * The selector will be for example, &quot;setOpaqueObject:&quot;.</div><div class="line">     * we need to remove the &quot;set&quot;,&quot;:&quot; and lowercase the first</div><div class="line">     * letter of the remainder</div><div class="line">     */</div><div class="line">    NSString *selectorString = NSStringFromSelector(_cmd);</div><div class="line">    NSMutableString *key = [selectorString mutableCopy];</div><div class="line">    // Remove the &quot;:&quot; at the end</div><div class="line">    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];</div><div class="line">    // Remove the &quot;set&quot; prefix</div><div class="line">    [key deleteCharactersInRange:NSMakeRange(0, 3)];</div><div class="line">    //Lowercase the first character</div><div class="line">    NSString *lowercaseFirstChar = [[key substringFromIndex:1] lowercaseString];</div><div class="line">    [key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];</div><div class="line">    if (value) &#123;</div><div class="line">        [backingStore setObject:value forKey:key];</div><div class="line">    &#125;else&#123;</div><div class="line">        [backingStore removeObjectForKey:key];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p> 若对象无法响应某个选择子，则进入消息转发流程</p>
<p> 通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中</p>
<p> 对象可以把其无法解读的某些选择子转交给其他对象处理</p>
<p> 经过上述两步之后，如果还是没办法处理选择子，那就启动完整的消息转发机制</p>
</blockquote>
<h2 id="13-用”方法调配技术”-调试”黑盒方法”"><a href="#13-用”方法调配技术”-调试”黑盒方法”" class="headerlink" title="13.用”方法调配技术” 调试”黑盒方法”"></a>13.用”方法调配技术” 调试”黑盒方法”</h2><hr>
<ul>
<li>我们既不需要源代码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能，新功能将在本类的所有实例中生效，而不是仅限于覆写了相关方法的那些子类实例。此方案经常成为”方法调配”</li>
<li>类的方法列表会把选择子的名称映射到相关的方法实现之上，使得”动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这种指针叫做IMP 原型如下: <code>id (* IMP)（id, SEL, …）</code></li>
<li><code>Objective-C</code>运行期系统提供的几个方法都能用来操作这张表。开发者可以向其中新增选择子，也可以改变某选择子所对应的方法实现，还可以交换两个选择子所映射到的指针。</li>
<li><code>void method_exchangeImplementations(Method m1, Method m2)</code>交换方法实现，参数表示带交换的两个方法实现</li>
<li><code>Method class_getInstanceMethod(Class cls, SEL name)</code>  方法实现函数获得</li>
<li><code>Example</code>交换<code>NSString</code> 实例方法                                                              <code>Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));</code><br><code>Method swppedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));
method_exchangeImplementations(originalMethod, swppedMethod);</code> </li>
<li>通过此方案，开发者可以为那些”完全不知道其具体实现的”黑盒方法增加日志记录功能，这非常有助于程序调式，然而，此做法只在调式程序时有用，很少有人在调式程序之外的场合用</li>
</ul>
<blockquote>
<p> 在运行期，可以向类中新增或替换选择子所对应的方法实现</p>
<p> 使用另一份实现来替换原有的方法实现，这道工序叫做”方法调配”，开发者常用此技术向原有实现中添加新功能</p>
<p> 一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不易滥用</p>
</blockquote>
<h2 id="14-理解”类对象”的用意"><a href="#14-理解”类对象”的用意" class="headerlink" title="14.理解”类对象”的用意"></a>14.理解”类对象”的用意</h2><hr>
<ul>
<li>“在运行期检视对象类型”这一操作也叫做”类型信息查询”，这个强大而有用的特性内置于<code>Foundation</code>框架的<code>NSObject</code>协议里，凡是由公共根类(即<code>NSObject</code>与<code>NSProxy</code>)继承而来的对象都要遵从此协议。在程序中不要直接比较对象所属的类，明智的做法是调用”类型信息查询方法”。</li>
<li>每一个<code>Objective-C</code>对象实例都是指向某块内存数据的指针。所以在声明变量时，类型后面跟一个”<em>”字符<br>`NSString </em>pointerVariable = @”Some string”;`</li>
<li>对于通用的对象类型id,由于其本身已经是指针了，所以我们能够这样写:<br><code>id pointerVariable = @&quot;Some string”;</code></li>
<li>描述<code>Objective-C</code>对象所用的数据结构定义在运行期程序库的头文件里，id类型本身也在定义在这里<br><img src="/2014/06/16/Effective-Objecive-C-2-0-读书笔记（二）/1.png" alt="1"><br>由此可见，每个对象结构体的首个成员是Class类的变量。该变量定义了对象所属的类，通常称为”isa”指针。<br><img src="/2014/06/16/Effective-Objecive-C-2-0-读书笔记（二）/2.png" alt="2"><br>此结构体存放类的”元数据”，例如类的实例实现了几个方法，具备多少个实例变量等信息。此结构体的首个变量也是isa指针，说明<code>Class</code>本身亦为<code>Objective-C</code>对象。结构体里还有个变量叫做<code>super_class</code>，它定义了本类的超类。类对象所属的类型是另外一个类，叫做”元类”，用来表述类对象本身具备的元数据。”类方法”就定义与此，因为这些方法可以理解成类对象的实例方法<br>。每个类仅有一个”类对象”，而每个”类对象”仅有一个与之相关的”元类”。<br><img src="/2014/06/16/Effective-Objecive-C-2-0-读书笔记（二）/3.png" alt="3"></li>
<li><code>super_class</code>指针确立了继承关系，而isa指针描述了实例所属的类。</li>
<li><code>isMemberOfClass</code> 能够判断出对象是否为某个特定类的实例</li>
<li><code>isKindOfClass</code> 则能够判断出对象是否为某类或其派生类的实例<br><img src="/2014/06/16/Effective-Objecive-C-2-0-读书笔记（二）/4.png" alt="4"></li>
<li>由于<code>Objective-C</code>使用”动态类型系统”，所以用于查询对象所属类的类型信息查询功能非常有用。<br><img src="/2014/06/16/Effective-Objecive-C-2-0-读书笔记（二）/5.png" alt="5"></li>
</ul>
<blockquote>
<p>每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系</p>
<p>如果对象类型无法再编译期确定，那么就应该使用类型信息查询方法来探知</p>
<p>尽量使用类型信息查询方法来确定对象类型，而不要直接比较对象，因为某些对象可能实现了消息转发功能。</p>
</blockquote>
<h2 id="15-用前缀避免命名空间冲突"><a href="#15-用前缀避免命名空间冲突" class="headerlink" title="15.用前缀避免命名空间冲突"></a>15.用前缀避免命名空间冲突</h2><hr>
<ul>
<li><code>Objective-C</code>没有命名空间机制</li>
<li>Apple宣称其保留使用所有”两字母前缀”的权利，所以你自己选用的前缀应该是三个字母</li>
<li>应该给C函数及全局变量的名字加上前缀</li>
</ul>
<blockquote>
<p>选择与你公司、应用程序或两者皆有关联之名作为类名的前缀，并在所有代码中均使用这一前缀</p>
<p>若自己所开发的程序中用到了第三方库，则应为其中的名称加上前缀</p>
</blockquote>
<h2 id="16-提供”全能初始化方法”"><a href="#16-提供”全能初始化方法”" class="headerlink" title="16.提供”全能初始化方法”"></a>16.提供”全能初始化方法”</h2><hr>
<ul>
<li>我们把对象提供必要信息以便其能完成工作的初始化方法叫做”全能初始化方法”</li>
<li>非预想初始化方法的应对方法  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//Using default values</div><div class="line">- (instancetype)init&#123;</div><div class="line">    return [self initWithWidth:5.0 andHeight:10.0];</div><div class="line">&#125;</div><div class="line">//Throwing an exception</div><div class="line">- (instancetype)init&#123;</div><div class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithWidth:andHeight: instead.&quot; userInfo:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>不过在<code>Objective-C</code>程序中，只有当发生严重错误时，才应该抛出异常。</li>
<li>如果子类的全能初始化方法与超类方法的名称不一样,那么总应该覆写超类的全能初始化方法</li>
<li>每一个子类的全能初始化方法都应该调用其超类的相关方法，并逐层向上。</li>
</ul>
<blockquote>
<p> 在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法</p>
<p> 若全能初始化方法与超类不同，则需覆写超类中的对应方法</p>
<p> 如果超类的初始化方法不适用与子类，那么应该覆写这个超类方法，并在其中抛出异常  </p>
</blockquote>
<h2 id="17-实现description方法"><a href="#17-实现description方法" class="headerlink" title="17.实现description方法"></a>17.实现description方法</h2><hr>
<ul>
<li>有个简单的方法，可以在 <code>description</code> 中输出很多互不相同的信息，那就是借助<code>NSDictionary</code>类的<code>description</code>方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSString*)description&#123;   </div><div class="line">return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;,[self class],self,@&#123;@&quot;width&quot;:@(_width),@&quot;height&quot;:@(_height)&#125;</div><div class="line">];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>NSObject</code>协议中还有个方法要注意，那就是<code>debugDescription</code>，此方法的用意与<code>description</code>非常相似。<code>debugDescription</code>方法是开发者在调试器中以控制台命令打印对象时才调用的</li>
</ul>
<blockquote>
<p>实现<code>description</code>方法返回一个意义的字符串，用以描述该实例</p>
<p>若想在调试时打印出更详尽的对象描述信息，则应实现<code>debugDescription</code>方法</p>
</blockquote>
<h2 id="18-尽量使用不可变对象"><a href="#18-尽量使用不可变对象" class="headerlink" title="18.尽量使用不可变对象"></a>18.尽量使用不可变对象</h2><hr>
<ul>
<li>在使用属性时，则可将其声明为”只读”，默认情况下，属性时”既可读又可写”的</li>
<li>应该尽量把对外公布出来的属性设为只读，而且只在确有必要时才将属性对外公布。</li>
<li>有时可能想修改封装在对象内部的数据，但是却不想令这些数据为外人所改动。通常做法就是在对象内部将readonly属性重新声明为readwrite。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interfaceTDRectangle()</div><div class="line">@property(nonatomic,assign,readwrite)float width;</div><div class="line">@property(nonatomic,assign,readwrite)float height;</div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li><p>更准确地说，在对象外部仍能通过”键值编码”<code>(Key-Value Coding,KVC)</code>技术设置这些属性值，<code>[rectangle setValue:@(10.0) forKey:@&quot;width”];</code>不过开发者使用这种”杂技代码(hack)的话，那么得自己来应对可能出现的问题”</p>
</li>
<li><p>一种情况，一个类通常提供一个<code>readonly</code>属性(<code>set</code>)供外界使用，但在内部这个属性是可变的，则应该属性将返回不可变的<code>set</code>,而此<code>set</code>则是内部那个可变<code>set</code>的一份拷贝。</p>
</li>
</ul>
<blockquote>
<p>尽量创建不可变的对象</p>
<p>若某属性仅可用于对象内部修改，则在”<code>class-continuation</code>分类”中将其有<code>readonly</code>属性扩展为<code>readwrite</code>属性</p>
<p>不要把可变的<code>collection</code>作为属性公开，而应该提供相关方法，以此修改对象中的可变<code>collection</code></p>
</blockquote>
<h2 id="19-使用清晰而协调的命名方式"><a href="#19-使用清晰而协调的命名方式" class="headerlink" title="19.使用清晰而协调的命名方式"></a>19.使用清晰而协调的命名方式</h2><hr>
<ul>
<li>方法与变量名使用”驼峰式大小写命名法”，以小写字母开头，其后每个字母首字母大写</li>
<li>类名也用驼峰命名法，不过其首字母要大写，而且前面通常还有两三个前缀字母</li>
<li>如果方法的返回值是新创建的，那么方法名的首个词应是返回值的类型，除非前面还有修饰语</li>
<li>应该把表示参数类型的名词放在参数前面</li>
<li>如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词</li>
<li>不要使用str这种简称，应该用string这样的全称</li>
<li><code>Boolean</code>属性应加is前缀。如果某方法返回非属性的<code>Boolean</code>值，那么应该根据某功能，选用has或is前缀</li>
</ul>
<blockquote>
<p>起名时应遵从标准的<code>Objective-C</code>命名规范</p>
<p>方法名要言简意核</p>
<p>方法名里不要使用缩略后的类型名称</p>
<p>给方法起名时的第一要务就是确保其风格与你自己的代码或多要集成的框架相符</p>
</blockquote>
<h2 id="20-为私有方法名加前缀"><a href="#20-为私有方法名加前缀" class="headerlink" title="20.为私有方法名加前缀"></a>20.为私有方法名加前缀</h2><hr>
<blockquote>
<p>给私有方法的名称加上前缀，这样可以很容易地将其同公共方法区分开</p>
<p>不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/05/Effective-Objecive-C-2-0-读书笔记（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AndyMu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyMu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/06/05/Effective-Objecive-C-2-0-读书笔记（一）/" itemprop="url">Effective-Objecive-C-2-0-读书笔记（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-05T16:20:28+08:00">
                2014-06-05
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2014/06/05/Effective-Objecive-C-2-0-读书笔记（一）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/06/05/Effective-Objecive-C-2-0-读书笔记（一）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-了解Objective-C语言的起源"><a href="#1-了解Objective-C语言的起源" class="headerlink" title="1.了解Objective-C语言的起源"></a>1.了解Objective-C语言的起源</h2><hr>
<ul>
<li>该语言使用”消息结构”而非”函数调用”  </li>
<li>使用消息结构的语言，其运行时所应执行的代码由运行环境来决定，而使用函数调用的语言，则由编译器决定  </li>
</ul>
<blockquote>
<p> <code>Objective-C</code> 为C语言添加了面向对象特性，是其超集。<code>Objective-C</code> 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行环境而非编译环境来决定  </p>
<p>理解C语言的核心概念有助于写好<code>Objective-C</code> 程序。尤其要掌握内存模型与指针</p>
</blockquote>
<h2 id="2-在类的头文件中尽量少引入其他头文件"><a href="#2-在类的头文件中尽量少引入其他头文件" class="headerlink" title="2.在类的头文件中尽量少引入其他头文件"></a>2.在类的头文件中尽量少引入其他头文件</h2><hr>
<ul>
<li>尽可能的使用<code>@class</code> 代替<code>#import</code> </li>
<li>将引入头文件的时机尽量延后，只在确定有需要时才引入，这样就可以减少类的使用者所需引入的头文件数量。当然就会减少编译时间</li>
<li>如果在各自头文件中引入对方头文件，则会导致”循环引用”，使用<code>#import</code> 而非<code>#include</code> 指令虽然不会导致死循环，但却意味着两个类里有一个无法被正确编译</li>
<li>子类则必须引入定义那个超类的头文件，同理，若遵循某个协议，那么该协议必须有完整的定义，且不能使用向前声明(<code>@class</code> )</li>
</ul>
<blockquote>
<p>除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之前的耦合(coupling)。</p>
<p>有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把”该类遵循某协议”的这条声明移至”<code>class-continuation</code> ”分类中。如果不行，就把协议单独放在一个头文件中，然后将其引入。</p>
</blockquote>
<h2 id="3-多用字面量语法，少用与之等价的方法"><a href="#3-多用字面量语法，少用与之等价的方法" class="headerlink" title="3.多用字面量语法，少用与之等价的方法"></a>3.多用字面量语法，少用与之等价的方法</h2><hr>
<ul>
<li>用字面量语法创建数组时要注意，若数组元素中有<code>nil</code> ，则会抛出异常</li>
<li>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的(immutable)。若想要可变版本的对象，则需要复制一份<code>NSMutableArray *mutable = [@[@1,@2,@3,@4,@5] mutableCopy];</code> </li>
</ul>
<blockquote>
<p>应该使用字面量语法来创建字符串、数组、数值、字典。与创建此类对象的常规方法相比，这么做更加简明扼要</p>
<p>应该通过取下标操作来访问数组下标或字典中的健所对应的元素</p>
<p>用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil</p>
</blockquote>
<h2 id="4-多用类型常量，少用-define预处理指令"><a href="#4-多用类型常量，少用-define预处理指令" class="headerlink" title="4.多用类型常量，少用#define预处理指令"></a>4.多用类型常量，少用#define预处理指令</h2><hr>
<ul>
<li>常量命名法是:若常量局限于某”实现文件”之内,则在前面加字母k，若常量在类之外可见，则通常以类名为前缀。</li>
<li><code>static</code> 修饰符则意味着该变量仅在定义此变量的编译单元可见。</li>
</ul>
<blockquote>
<p> 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会警告信息，这将导致应用程序中的常量值不一致</p>
<p>在实现文件中使用<code>static const</code>  来定义”只在编译单元内可见的常量”。由于此类常量不在全局符号表中，所以无须为其名称前缀</p>
<p>在头文件中使用<code>extern</code> 来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀</p>
</blockquote>
<h2 id="5-用枚举表示状态、选项、状态码"><a href="#5-用枚举表示状态、选项、状态码" class="headerlink" title="5.用枚举表示状态、选项、状态码"></a>5.用枚举表示状态、选项、状态码</h2><hr>
<ul>
<li><code>typedef</code> 关键字重新定义枚举类型</li>
<li>尽量使用枚举的新特性，指明用何种”底层数据类型”来保存枚举类型的变量。</li>
<li>凡是需要以按位或操作来组合的枚举都应该使用<code>NS_OPTIONS</code> 定义，若枚举不需要组合，则应该使用来<code>NS_ENUM</code> 定义 </li>
</ul>
<blockquote>
<p> 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字</p>
<p>如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为3的幂，以便通过按位或操作将其组合起来</p>
<p>用<code>NS_ENUM</code> 与<code>NS_OPTIONS</code> 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型</p>
<p>在处理枚举类型的<code>switch</code> 语句中不要实现<code>default</code> 分支。这样的话，加入新枚举之后，编译器就会提示开发者：<code>switch</code> 语句并未处理所有的枚举</p>
</blockquote>
<h2 id="6-理解”属性”这一概念"><a href="#6-理解”属性”这一概念" class="headerlink" title="6.理解”属性”这一概念"></a>6.理解”属性”这一概念</h2><hr>
<ul>
<li>使用属性，编译器就会自动编写访问这些属性所需的方法，此过程就叫“自动合成”，这个过程由编译器在编译期执行</li>
<li>使用<code>@dynamic</code> 关键字，编译器就不会自动创建实行属性所用的实例变量，也不会创建存取方法</li>
<li><code>assign</code> 是只会执行针对”纯量类型”的简单赋值操作</li>
<li><code>strong</code> 一种”拥有关系”，为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去</li>
<li><code>weak</code> 一种”非拥有关系”，为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，此特质同类<code>assign</code> 似，然而在属性所指的对象遭到摧毁时，属性值也会清空</li>
<li><code>unsafe_unretained</code> 语义和<code>assign</code> 相同，但是它适用于”对象类型”，一种”非拥有关系”，当目标对象遭到摧毁时，属性值不会自动清空</li>
<li><code>copy</code> 所表达的所属关系与<code>strong</code> 类似，然而设置方法并不保留新值，而是将其“拷贝”。主要是防止在对象不知情的情况下遭人修改</li>
</ul>
<blockquote>
<p>可以用<code>@property</code> 语法来定义对象中所封装的数据</p>
<p>通过”特质”来指定存储数据所需的正确语义</p>
<p>在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义</p>
<p>开发iOS程序时应该使用<code>nonatomic</code> 属性，因为<code>atomic</code> 属性会严重影响性能</p>
</blockquote>
<h2 id="7-在对象内部尽量使用实例变量"><a href="#7-在对象内部尽量使用实例变量" class="headerlink" title="7.在对象内部尽量使用实例变量"></a>7.在对象内部尽量使用实例变量</h2><hr>
<ul>
<li>由于不经过<code>Objective-C</code> 的”方法派发”，实例变量的访问速度特别的快，编译器所执行的代码会直接访问保存对象实例变量的那块内存</li>
<li>直接访问实例变量时，不会调用其”设置方法”，这就绕过了为相关属性所定义的”内存管理语义”，在ARC下访问一个声明<code>copy</code> 的属性，那么并不会拷贝该属性</li>
<li>直接访问实例变量，不会触发”键值观测”KVO通知。</li>
<li>在基类默认的初始化方法中，此时若是通过”设置方法”来做，那么调用的可能会是子类的设置方法</li>
<li>“懒加载”必须通过”获取方法”来访问属性，否则，实例变量就永远不会初始化</li>
</ul>
<blockquote>
<p>在对象内部读数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写</p>
<p>在初始化方法及<code>dealloc</code> 方法中，总是应该直接通过实例变量来读写数据</p>
<p>有时会使用懒加载初始化技术配置某分数据，这种情况下，需要通过属性来读取数据</p>
</blockquote>
<h2 id="8-理解”对象等同性”这一概念"><a href="#8-理解”对象等同性”这一概念" class="headerlink" title="8.理解”对象等同性”这一概念"></a>8.理解”对象等同性”这一概念</h2><hr>
<ul>
<li>==比较的是两个指针本身，而不是其所指的对象</li>
<li>实现”<code>isEqual</code> ”方法时要考虑到两个对象是否属于同一个类，父类的实例可以与其子类实例相等</li>
</ul>
<blockquote>
<p>若想检测对象的等同性，请提供“<code>isEqual</code> :”与<code>hash</code> 方法</p>
<p>相同的对象必须具备有相同的哈希吗，但是两个哈希吗相同的对象却未必相同</p>
<p>不要盲目的逐个检测每条属性，而是应该依照具体需求来制定检测方案</p>
<p>编写hash方法时，应该使用计算速度快并且哈希吗碰撞几率低的算法</p>
</blockquote>
<h2 id="9-以”类族模式”隐藏实现细节"><a href="#9-以”类族模式”隐藏实现细节" class="headerlink" title="9.以”类族模式”隐藏实现细节"></a>9.以”类族模式”隐藏实现细节</h2><hr>
<blockquote>
<p>类族模式可以把实现细节隐藏在一套简单的公共接口后面</p>
<p>系统框架中经常使用类族</p>
<p>从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读  </p>
</blockquote>
<h2 id="10-在既有类中使用关联对象存放自定义数据"><a href="#10-在既有类中使用关联对象存放自定义数据" class="headerlink" title="10.在既有类中使用关联对象存放自定义数据"></a>10.在既有类中使用关联对象存放自定义数据</h2><hr>
<ul>
<li>有些类的实例可能是由某种机制所创建，而开发者无法令这种机制创建自己所写的子类实例</li>
<li>关联类型                            等效<code>@property</code> 属性</li>
<li><code>OBJC_ASSOCIATION_ASSIGN</code>              <code>assign</code> </li>
<li><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>    <code>nonationmic</code> ,<code>retain</code> </li>
<li><code>OBJC_ASSOCIATION_COPY_NONATOMIC</code>      <code>nonationmic</code> ,<code>copy</code> </li>
<li><code>OBJC_ASSOCIATION_RETAIN</code>              <code>retain</code> </li>
<li><code>OBJC_ASSOCIATION_COPY</code>                <code>copy</code> </li>
<li><code>objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</code>  此方法已给定的键和策略为某对象设置关联对象</li>
<li><code>objc_getAssociatedObject(id object, const void *key)</code>  此方法根据给定的键从某对象中获取相应的关联对象值</li>
<li><code>objc_removeAssociatedObjects(id object)</code> 此方法移除指定对象的全部关联对象</li>
<li>在设置关联对象值时，通常使用静态全局变量做键  <code>static void *EOCMyAlertViewKey = “EOCMyAlertViewKey”</code>  或者<code>@selector(XXXXX)</code> </li>
</ul>
<blockquote>
<p>可以通过”关联对象”机制来把两个对象连起来</p>
<p>定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与”非拥有关系”</p>
<p>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/04/25/Xcode-File-Templates-巧用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AndyMu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AndyMu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/04/25/Xcode-File-Templates-巧用/" itemprop="url">Xcode File Templates 巧用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-04-25T23:52:14+08:00">
                2014-04-25
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2014/04/25/Xcode-File-Templates-巧用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/04/25/Xcode-File-Templates-巧用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是-File-Templates"><a href="#什么是-File-Templates" class="headerlink" title="什么是 File Templates?"></a>什么是 File Templates?</h2><hr>
<p>说File Templates 可能很多人不知道是什么，但是如果说Cocoa Touch Class大家应该就不陌生了，作为一名iOS开发者，我们无时无刻不在使用Xcode,不在创建新的NSObject、UIViewController、xib、storyboard等文件。我们在创建这些文件的时候Xcode会自动帮我们集成一套模板。</p>
<p><strong>系统模板路径(xcode(8.2.1)可能不同版本路径不一样)</strong>  </p>
<pre><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/File Templates/Source
</code></pre><p><strong>其实File Templates下文件和Xcode-&gt;new-&gt;file 是对应的如图:</strong><br><img src="/2014/04/25/Xcode-File-Templates-巧用/1.png" alt="1"><br><img src="/2014/04/25/Xcode-File-Templates-巧用/2.png" alt="2"></p>
<h2 id="Template文件夹"><a href="#Template文件夹" class="headerlink" title=".Template文件夹"></a>.Template文件夹</h2><hr>
<blockquote>
<p>模版文件夹：里面包含<code>___FILEBASENAME___.h</code>、<code>___FILEBASENAME___.m</code> 、<code>___FILEBASENAME___.xib</code>、<code>___FILEBASENAME___.swift</code>、<code>___FILEBASENAME___.xib</code>等文件。<br>TemplateIcon.png：模版显示的图片。<br>TemplateInfo.plist：模版的配置信息。</p>
</blockquote>
<h2 id="TemplateInfo-plist"><a href="#TemplateInfo-plist" class="headerlink" title="TemplateInfo.plist"></a>TemplateInfo.plist</h2><hr>
<p><img src="/2014/04/25/Xcode-File-Templates-巧用/3.png" alt="3"></p>
<blockquote>
<p>SortOrder 模板在界面中的位置<br>Options 创建file的四个选项  </p>
<blockquote>
<p>Item 1 -&gt; Default： 默认显示Class<br>Item 1 -&gt; FallbackHeader： 默认.h导入的头文件<br>Item 1 -&gt; Values： 模板的名称<br>Item 1 -&gt; Suffixes： 创建相应模板的默认名称<br>Item 2 -&gt; RequiredOptions -&gt; cocoaSubclass：是否支持选择 xib；</p>
</blockquote>
</blockquote>
<h2 id="常用编译器定义的宏"><a href="#常用编译器定义的宏" class="headerlink" title="常用编译器定义的宏"></a>常用编译器定义的宏</h2><hr>
<blockquote>
<p>DATE：标识当前时间；<br>FILENAME：带文件后缀的全名；<br>FILEBASENAME：不带文件后缀的名字；<br>FULLUSERNAME：当前的用户名；<br>PROJECTNAME：工程名字；<br>FILEBASENAMEASIDENTIFIER： VC类名称；<br>IMPORTHEADER_cocoaSubclass： 导入的头文件。   </p>
</blockquote>
<h5 id="到此自己可以自定义自己的模板了"><a href="#到此自己可以自定义自己的模板了" class="headerlink" title="到此自己可以自定义自己的模板了!!!"></a>到此自己可以自定义自己的模板了!!!</h5><hr>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="AndyMu" />
          <p class="site-author-name" itemprop="name">AndyMu</p>
           
              <p class="site-description motion-element" itemprop="description">我是一只有点懒惰的小蚂蚁,为着自己的大米在码农的日子上渐行渐远。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhenhuamu" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2684149271/profile?topnav=1&wvr=6" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微博
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AndyMu</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhenhuamu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  





  

  

  

  

  

  

</body>
</html>
